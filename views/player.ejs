<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jukebar - Player</title>
    <link rel="icon" href="/img/favicon.png">
    <link rel="stylesheet" href="/styles.css">
    <script src="/socket.io/socket.io.js"></script>

</head>

<body>
    <div id="notification" class="notification">
        <span class="close-btn" id="close-notification">&times;</span>
        <p id="notification-text"></p>
    </div>
    <%- include('partials/header', { page: 'player' }) %>
        <div class="main-content">
            <p class="user-greeting">Logged in as: <strong>
                    <%= user %>
                </strong></p>
            <div class="container">
                <div id="spotifyPlayer">
                    <form id="searchForm">
                        <div class="search-container">
                            <input type="text" id="searchInput" placeholder="Search for a song, artist, or album"
                                required>
                            <button type="submit" id="searchButton">
                                <img src="/img/search.png" alt="Search" class="search-icon">
                            </button>
                        </div>
                    </form>
                    <% if (userID===ownerID) { %>
                        <div class="owner-anon-container">
                            <label class="owner-anon-label">
                                <input type="checkbox" id="owner-anon-mode">
                                Add songs anonymously
                            </label>
                        </div>
                        <% } %>
                            <div id="searchResults"></div>
                </div>
                <div id="songStats">
                    <h2>Now Playing:</h2>
                    <hr>
                    <div id="currentlyPlaying">
                    </div>
                    <div>
                        <button id="skip-button" class="skip-button">Skip</button>
                    </div>
                    <h2>Up Next:</h2>
                    <hr>
                    <div id="queue">
                    </div>
                </div>
            </div>
        </div>
        <div id="paymentModal" class="payment-modal">
            <div class="payment-content">
                <button id="hide-payment">&times;</button>
                <%- include('partials/pay') %>
            </div>
        </div>

        <button id="changelog-button" class="changelog-button" title="View Changelog">
            <img src="/img/changelog.png" alt="Changelog">
        </button>

        <div id="changelogModal" class="changelog-modal">
            <div class="changelog-content">
                <button id="close-changelog" class="close-changelog">&times;</button>
                <%- include('partials/changelog') %>
            </div>
        </div>

        <div id="songMenuModal">
            <div class="song-menu-content">
                <button id="hide-song-menu">&times;</button>
                <%- include('partials/songMenu') %>
            </div>
        </div>

        <script>
            const userPermission = <%= userPermission %>;
            
            // Global variables that need to be accessed by multiple functions
            let currentlyPlayingUri = null;
            let currentProgress = 0; // Current progress in ms
            let currentDuration = 0; // Track duration in ms
            let isCurrentlyPlaying = false;
            let progressInterval = null;

            (function () {
                'use strict';

                let useJukebar = true;

                const socket = io();

                socket.on('auxiliaryPermission', (permission) => {
                    if (permission <= userPermission) {
                        useJukebar = true;
                    } else {
                        useJukebar = false;
                    }
                });

                // Global payment status flag
                let hasPaid = <%= JSON.stringify(hasPaid || false) %>;
                let currentID = <%= JSON.stringify(userID || null) %>;
                let pendingTrackUri = null;
                let pendingAction = null;
                const ownerID = <%= JSON.stringify(ownerID) %>;

                function handleSearchSubmit(event) {
                    event.preventDefault();
                    searchSpotify();
                }

                async function checkPaymentAndPlay(uri) {
                    // Check if Jukebar is enabled
                    if (!useJukebar) {
                        Notify('Jukebar is currently disabled by your teacher.', 'error');
                        return;
                    }

                    if (currentID === ownerID) {
                        const anonMode = document.getElementById('owner-anon-mode')?.checked || false;
                        addToQueue(uri, anonMode);
                        return;
                    }

                    if (!hasPaid) {
                        pendingTrackUri = uri;
                        pendingAction = 'play';
                        showPayment();
                        return;
                    }

                    // Reset payment flag after using it
                    hasPaid = false;
                    addToQueue(uri);
                }

                async function checkPaymentAndSkip() {
                    console.log('‚è≠Ô∏è Skip clicked - currentlyPlayingUri:', currentlyPlayingUri);
                    
                    // Check if Jukebar is enabled
                    if (!useJukebar) {
                        Notify('Jukebar is currently disabled by your teacher.', 'error');
                        return;
                    }

                    // Build the full URI - add prefix only if not already present
                    let skipUri = currentlyPlayingUri;
                    if (currentlyPlayingUri && !currentlyPlayingUri.startsWith('spotify:track:')) {
                        skipUri = `spotify:track:${currentlyPlayingUri}`;
                    }

                    console.log('‚è≠Ô∏è Final skipUri:', skipUri);
                    
                    if (currentID === ownerID || Number(currentID) === Number(ownerID)) {
                        skip(skipUri);
                        return;
                    }

                    if (!hasPaid) {
                        pendingTrackUri = skipUri;
                        pendingAction = 'skip';
                        showPayment();
                        return;
                    }

                    // Reset payment flag after using it
                    hasPaid = false;
                    skip(skipUri);
                }

                async function skip(uri) {
                    try {
                        const response = await fetch('/skip', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ uri })
                        });
                        
                        const data = await response.json();
                        
                        if (data.shieldBlocked) {
                            // Skip was blocked by a shield
                            Notify(data.message || 'Skip blocked by shield! üõ°Ô∏è', 'error');
                        } else if (data.ok) {
                            // Skip succeeded
                            Notify('Track skipped!', 'success');
                        } else {
                            // Other error
                            Notify(data.error || 'Failed to skip', 'error');
                            refund();
                        }
                    } catch (error) {
                        console.error('Error skipping track:', error);
                        Notify('Network error', 'error');
                    }
                }

                function addToQueue(uri, anonMode = null) {
                    if (anonMode === null) {
                        anonMode = document.getElementById('anonMode')?.checked || false;
                    }
                    fetch('/addToQueue', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ uri, anonMode })
                    })
                        .then(response => {
                            if (response.ok) {
                                Notify('Track added to queue!', 'success');
                            } else {
                                return response.json().then(data => {
                                    refund();
                                });
                            }
                        })
                        .catch(error => {
                            //console.log('oopsies!')
                            console.error('Error adding track to queue:', error);
                            Notify('Network error', 'error');
                        });
                }

                async function searchSpotify() {
                    const query = document.getElementById('searchInput').value;
                    if (!query) return;

                    try {
                        const response = await fetch('/search', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ query })
                        });
                        const data = await response.json();
                        const resultsDiv = document.getElementById('searchResults');
                        resultsDiv.innerHTML = '';

                        if (data.tracks && data.tracks.items.length > 0) {
                            data.tracks.items.forEach(track => {
                                const trackDiv = document.createElement('div');
                                trackDiv.className = 'search-result-item';
                                trackDiv.innerHTML = `
                        <img src="${track.album.image}" alt="${track.album.name}" class="album-cover" />
                        <div class="search-result-content">
                            <div class="search-result-title">${track.name}</div>
                            <div class="search-result-artist">${track.artist}</div>
                        </div>
                        <button class="play-button" data-uri="${track.uri}">Play</button>
                    `;
                                resultsDiv.appendChild(trackDiv);
                            });
                        } else {
                            resultsDiv.innerHTML = '<p>No results found.</p>';
                        }
                    } catch (error) {
                        console.error('Error searching Spotify:', error);
                    }
                }

                async function getQueue() {
                    try {
                        const response = await fetch('/getQueue', {
                            method: 'GET',
                            headers: { 'Content-Type': 'application/json' }
                        });
                        const data = await response.json();
                        if (data.ok) {
                            const queueDiv = document.getElementById('queue');
                            queueDiv.innerHTML = '';
                            if (data.tracks.items.length == 0) {
                                queueDiv.innerHTML = '<p>No tracks in queue.</p>';
                            } else {
                                data.tracks.items.forEach((item, index) => {
                                    const itemDiv = document.createElement('div');
                                    itemDiv.className = 'queue-item';

                                    // Handle anonymous mode
                                    let addedByDisplay = item.addedBy;
                                    if (typeof addedByDisplay === 'object' || addedByDisplay === '[object Object]') {
                                        addedByDisplay = 'Spotify';
                                    }

                                    // Check if anonymous mode and user is not a teacher
                                    if ((item.isAnon === 1 || item.isAnon === true) && userPermission < 4) {
                                        addedByDisplay = 'Anonymous';
                                    }

                                    itemDiv.innerHTML = `
                                        <img src="${item.album.image}" alt="${item.album.name}" class="album-cover" />
                                        <div class="queue-item-content">
                                            <div class="queue-item-title">${item.name}</div>
                                            <div class="queue-item-artist">${item.artist}</div>
                                            <div class="queue-item-added-by">Added by ${addedByDisplay || 'Spotify'}</div>
                                        </div>
                                    `;
                                    queueDiv.appendChild(itemDiv);
                                });
                            }
                        } else {
                            console.error('Failed to get queue:', data.error);
                        }
                    } catch (error) {
                        console.error('Error fetching queue:', error);
                    }
                }

                async function currentlyPlaying() {
                    try {
                        const response = await fetch('/currentlyPlaying', {
                            method: 'GET',
                            headers: { 'Content-Type': 'application/json' }
                        });
                        const data = await response.json();
                        if (data.ok) {
                            //console.log('Currently Playing:', data.tracks.items);
                            const CurrentDiv = document.getElementById('currentlyPlaying');
                            CurrentDiv.innerHTML = '';
                            if (data.tracks.items.length == 0) {
                                const CurrentDiv = document.getElementById('currentlyPlaying');
                                CurrentDiv.innerHTML = '<p>No track is currently playing. Ask your teacher to start spotify</p>';
                                currentlyPlayingUri = null;
                            }
                            else {
                                data.tracks.items.forEach((item, index) => {
                                    const itemDiv = document.createElement('div');
                                    itemDiv.className = 'current-item';
                                    itemDiv.innerHTML = `
                                    <img src="${item.album.image}" alt="${item.album.name}" class="album-cover" />
                                    <div class="current-item-content">
                                        <div class="current-item-title">${item.name}</div>
                                        <div class="current-item-artist">${item.artist}</div>
                                    </div>`;
                                    CurrentDiv.appendChild(itemDiv);
                                    currentlyPlayingUri = item.id
                                });
                            }
                        } else {
                            console.error('Failed to get current track:', data.error);
                        }
                    } catch (error) {
                        console.error('Error fetching current track:', error);
                    }
                }

                function showPayment() {
                    document.getElementById('paymentModal').style.display = 'block';
                    document.querySelector('.main-content').classList.add('blurred');
                    // Trigger getPrice via custom event
                    window.dispatchEvent(new CustomEvent('updatePrice', { detail: { pendingAction } }));
                }

                function hidePayment() {
                    document.getElementById('paymentModal').style.display = 'none';
                    document.querySelector('.main-content').classList.remove('blurred');

                    // Handle pending actions after payment
                    if (hasPaid && pendingAction) {
                        // Add a small delay to ensure session is saved on server
                        setTimeout(() => {
                            if (pendingAction === 'play' && pendingTrackUri) {
                                const uri = pendingTrackUri;
                                pendingTrackUri = null;
                                pendingAction = null;
                                checkPaymentAndPlay(uri);
                            } else if (pendingAction === 'skip') {
                                pendingAction = null;
                                checkPaymentAndSkip();
                            } else if (pendingAction === 'Skip Shield' && pendingTrackUri) {
                                const uri = pendingTrackUri;
                                pendingTrackUri = null;
                                pendingAction = null;
                                purchaseShieldAfterPayment(uri);
                            }
                        }, 100); // 100ms delay
                    }
                }

                function onPaymentSuccess() {
                    hasPaid = true;
                    hidePayment();
                }

                function refund() {
                    fetch('/refund', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ reason: "Jukebar refund" })
                    })
                        .then(response => response.json())
                        .then(data => {
                            if (data.ok) {
                                Notify('Spotify error occurred. Your digipogs have been refunded.', 'success');
                                //console.log('Refund successful:', data);
                            } else {
                                Notify('Refund failed: ' + (data.error || 'Unknown error'), 'error');
                                console.error('Refund failed:', data.error);
                            }
                        })
                        .catch(error => {
                            Notify('Network error during refund. Please contact support.', 'error');
                            console.error('Error during refund:', error);
                        });
                }

                // custom notifications taken from my other project
                let notificationTimeout;

                function Notify(message, type = 'info') {
                    let notification = document.getElementById("notification");
                    let notificationText = document.getElementById("notification-text");

                    notificationText.textContent = message;

                    // Remove any existing type classes
                    notification.classList.remove('notification-success', 'notification-error', 'notification-info');

                    // Add the appropriate type class
                    if (type === 'error') {
                        notification.classList.add('notification-error');
                    } else {
                        // default to success for other types
                        notification.classList.add('notification-success');
                    }

                    notification.style.display = "block";
                    setTimeout(() => notification.style.opacity = "1", 100);

                    clearTimeout(notificationTimeout);
                    notificationTimeout = setTimeout(closeNotification, 5000);
                }

                function closeNotification() {
                    let notification = document.getElementById("notification");
                    clearTimeout(notificationTimeout);

                    notification.style.opacity = "0";
                    setTimeout(() => notification.style.display = "none", 500);
                }


                // Wire up event listeners
                document.getElementById('searchForm')?.addEventListener('submit', handleSearchSubmit);
                document.getElementById('skip-button')?.addEventListener('click', checkPaymentAndSkip);
                document.getElementById('hide-payment')?.addEventListener('click', hidePayment);
                document.getElementById('close-notification')?.addEventListener('click', closeNotification);

                // Changelog button event listeners
                document.getElementById('changelog-button')?.addEventListener('click', () => {
                    document.getElementById('changelogModal').style.display = 'block';
                });

                document.getElementById('close-changelog')?.addEventListener('click', () => {
                    document.getElementById('changelogModal').style.display = 'none';
                });

                // Song menu button event listeners
                document.getElementById('hide-song-menu')?.addEventListener('click', () => {
                    document.getElementById('songMenuModal').style.display = 'none';
                    document.querySelector('.main-content').classList.remove('blurred');
                });

                // Close modal when clicking outside of it
                window.addEventListener('click', (event) => {
                    const changelogModal = document.getElementById('changelogModal');
                    if (event.target === changelogModal) {
                        changelogModal.style.display = 'none';
                    }
                    
                    const songMenuModal = document.getElementById('songMenuModal');
                    if (event.target === songMenuModal) {
                        songMenuModal.style.display = 'none';
                        document.querySelector('.main-content').classList.remove('blurred');
                    }
                });

                // Event delegation for dynamically created play buttons
                document.getElementById('searchResults')?.addEventListener('click', (e) => {
                    if (e.target.matches('.play-button') || e.target.closest('.play-button')) {
                        const button = e.target.matches('.play-button') ? e.target : e.target.closest('.play-button');
                        const uri = button.dataset.uri;
                        if (uri) checkPaymentAndPlay(uri);
                    }
                });

                // Expose minimal API via custom events for pay.ejs communication
                window.addEventListener('paymentSuccess', () => {
                    onPaymentSuccess();
                });

                window.addEventListener('hidePaymentModal', () => {
                    hidePayment();
                });

                // Expose read-only state for pay.ejs (cannot be directly manipulated from console)
                window.getPlayerState = function () {
                    return {
                        hasPaid: hasPaid,
                        pendingAction: pendingAction,
                        pendingTrackUri: pendingTrackUri,
                        currentID: currentID
                    };
                };

                window.setPlayerState = function (updates) {
                    if (updates.hasPaid !== undefined) hasPaid = updates.hasPaid;
                    if (updates.pendingAction !== undefined) pendingAction = updates.pendingAction;
                };

                window.purchaseShield = function (trackUri) {
                    if (!useJukebar) {
                        Notify('Jukebar is currently disabled by your teacher.', 'error');
                        return;
                    }
                    
                    // Owner can purchase shields for free without payment modal
                    if (currentID === ownerID || Number(currentID) === Number(ownerID)) {
                        purchaseShieldAfterPayment(trackUri);
                        return;
                    }
                    
                    pendingTrackUri = trackUri;
                    pendingAction = 'Skip Shield';
                    showPayment();
                };

                async function purchaseShieldAfterPayment(trackUri) {
                    try {
                        const response = await fetch('/purchaseShield', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ trackUri })
                        });

                        const data = await response.json();

                        if (response.ok && data.ok) {
                            Notify(data.message || 'Skip Shield added successfully!', 'success');
                            // Reset payment flag after successful purchase
                            hasPaid = false;
                            // Refresh queue to show updated shield count
                            socket.emit('getQueue');
                        } else {
                            Notify(data.error || 'Failed to add Skip Shield', 'error');
                        }
                    } catch (err) {
                        console.error('Error purchasing shield:', err);
                        Notify('Network error purchasing Skip Shield', 'error');
                    }
                }

                // Initialize WebSocket-based queue sync
                initializeQueueSync();
            })();

            // WebSocket-based queue synchronization
            function initializeQueueSync() {
                const socket = io();

                socket.on('connect', () => {
                    socket.emit('requestQueueUpdate');
                });

                // Handle initial state
                socket.on('initialState', (data) => {
                    updateQueueDisplay(data.data);
                    updateCurrentlyPlaying(data.data.currentTrack, data.data.isPlaying);
                });

                // Handle queue updates (when queue changes)
                socket.on('queueUpdate', (data) => {
                    updateQueueDisplay(data);
                    // Only update currently playing if we have valid current track data
                    if (data.currentTrack) {
                        updateCurrentlyPlaying(data.currentTrack, data.isPlaying);
                    }
                });

                // Handle playback state updates (playing/paused status)
                socket.on('playbackState', (data) => {
                    updateCurrentlyPlaying(data.currentTrack, data.isPlaying);
                });

                // Handle current track updates (from periodic sync)
                socket.on('currentTrack', (data) => {
                    //console.log('currentTrack event received:', data);
                    updateCurrentlyPlaying(data, true);
                });

                // Handle notifications only
                socket.on('queueAdd', (data) => {
                    showNotification(`"${data.track.name}" added to queue`, 'success');
                });

                socket.on('skip', (data) => {
                    showNotification('Track skipped', 'info');
                });

                // Handle shield purchase confirmation
                socket.on('shieldPurchased', (data) => {
                    if (data.ok) {
                        Notify(data.message || 'Skip Shield added! üõ°Ô∏è', 'success');
                        socket.emit('getQueue'); // Refresh queue
                    } else {
                        Notify(data.error || 'Failed to add Skip Shield', 'error');
                    }
                });
            }

            // Update queue display with WebSocket data
            function updateQueueDisplay(data) {
                const queueDiv = document.getElementById('queue');
                if (!queueDiv) return;

                // Handle different data structures
                let queue = data.queue || data.data?.queue || [];

                if (queue && queue.length > 0) {
                    //console.log('Displaying', queue.length, 'tracks');
                    queueDiv.innerHTML = queue.map((track, index) => {
                        // Safely convert addedBy to string, handling [object Object] cases
                        let addedByDisplay = track.addedBy;
                        if (typeof addedByDisplay === 'object' || addedByDisplay === '[object Object]') {
                            addedByDisplay = 'Spotify';
                        }

                        if ((track.isAnon === 1 || track.isAnon === true) && userPermission < 3) {
                            addedByDisplay = 'Anonymous';
                        }

                        const shieldCount = track.skipShields || 0;
                        
                        return `
                        <div class="queue-item">
                            <img src="${track.image}" alt="${track.name}" class="album-cover-small">
                            <div class="queue-item-content">
                                <div class="queue-item-title">${track.name}</div>
                                <div class="queue-item-artist">${track.artist}</div>
                                <div class="queue-item-added-by">Added by ${addedByDisplay || 'Spotify'}</div>
                                ${shieldCount > 0 ? `<span class="shield-badge">üõ°Ô∏è ${shieldCount}</span>` : ''}
                            </div>
                            <button class="ellipsis-button" onclick="openSongMenu('${track.uri}', '${track.name.replace(/'/g, "\\'")}', '${track.artist.replace(/'/g, "\\'")}', '${track.image}')" title="More options">
                                <svg width="16" height="4" viewBox="0 0 16 4" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <circle cx="2" cy="2" r="2" fill="currentColor"/>
                                    <circle cx="8" cy="2" r="2" fill="currentColor"/>
                                    <circle cx="14" cy="2" r="2" fill="currentColor"/>
                                </svg>
                            </button>
                        </div>
                    `;
                    }).join('');
                } else {
                    //console.log('QUEUE CLEARED - No tracks in queue, showing empty message');
                    queueDiv.innerHTML = '<p class="no-queue">No tracks in queue</p>';
                }
            }

            // Update currently playing with WebSocket data
            function updateCurrentlyPlaying(track, isPlaying) {
                const currentDiv = document.getElementById('currentlyPlaying');
                if (!currentDiv) return;

                if (track) {
                    // Update global currentlyPlayingUri for skip functionality
                    if (track.uri) {
                        currentlyPlayingUri = track.uri.replace('spotify:track:', '');
                        console.log('Now playing URI:', currentlyPlayingUri);
                    } else if (track.id) {
                        currentlyPlayingUri = track.id;
                        console.log('Now playing ID:', currentlyPlayingUri);
                    } else {
                        console.log('WARNING: No URI in track:', track);
                    }
                    
                    // Update global progress variables
                    currentProgress = track.progress || 0;
                    currentDuration = track.duration || 0;
                    isCurrentlyPlaying = isPlaying;
                    
                    // Handle anonymous mode display
                    let addedByDisplay = track.addedBy || 'Spotify';
                    if (typeof addedByDisplay === 'object' || addedByDisplay === '[object Object]') {
                        addedByDisplay = 'Spotify';
                    }
                    if ((track.isAnon === 1 || track.isAnon === true) && userPermission < 3) {
                        addedByDisplay = 'Anonymous';
                    }

                    const shieldCount = track.skipShields || 0;
                    
                    // Format time as mm:ss
                    const formatTime = (ms) => {
                        const totalSeconds = Math.floor(ms / 1000);
                        const minutes = Math.floor(totalSeconds / 60);
                        const seconds = totalSeconds % 60;
                        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    };
                    
                    const currentTime = formatTime(currentProgress);
                    const totalTime = formatTime(currentDuration);
                    
                    const imageUrl = track.image || track.album?.image || '/img/placeholder.png';
                    
                    currentDiv.innerHTML = `
                        <div class="current-item queue-item">
                            <img src="${imageUrl}" alt="${track.name}" class="album-cover-small">
                            <div class="queue-item-content">
                                <div class="queue-item-title">${track.name}</div>
                                <div class="queue-item-artist">${track.artist}</div>
                                <div class="queue-item-added-by">Added by ${addedByDisplay}</div>
                                <div class="track-progress" id="track-progress-display">${currentTime} / ${totalTime}</div>
                                ${shieldCount > 0 ? `<span class="shield-badge">üõ°Ô∏è ${shieldCount}</span>` : ''}
                            </div>
                            <button class="ellipsis-button" onclick="openSongMenu('${track.uri}', '${track.name.replace(/'/g, "\\'")}', '${track.artist.replace(/'/g, "\\'")}', '${imageUrl}')" title="More options">
                                <svg width="16" height="4" viewBox="0 0 16 4" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <circle cx="2" cy="2" r="2" fill="currentColor"/>
                                    <circle cx="8" cy="2" r="2" fill="currentColor"/>
                                    <circle cx="14" cy="2" r="2" fill="currentColor"/>
                                </svg>
                            </button>
                        </div>
                    `;
                    
                    // Start progress update interval
                    startProgressInterval();
                } else {
                    currentlyPlayingUri = null;
                    currentProgress = 0;
                    currentDuration = 0;
                    isCurrentlyPlaying = false;
                    stopProgressInterval();
                    currentDiv.innerHTML = '<p>No track is currently playing. Ask your teacher to start spotify</p>';
                }
            }
            
            // Start interval to update progress every second
            function startProgressInterval() {
                stopProgressInterval(); // Clear any existing interval
                
                progressInterval = setInterval(() => {
                    if (isCurrentlyPlaying && currentProgress < currentDuration) {
                        currentProgress += 1000; // Increment by 1 second
                        updateProgressDisplay();
                    }
                }, 1000);
            }
            
            // Stop progress interval
            function stopProgressInterval() {
                if (progressInterval) {
                    clearInterval(progressInterval);
                    progressInterval = null;
                }
            }
            
            // Update just the progress display without re-rendering everything
            function updateProgressDisplay() {
                const progressDisplay = document.getElementById('track-progress-display');
                if (progressDisplay) {
                    const formatTime = (ms) => {
                        const totalSeconds = Math.floor(ms / 1000);
                        const minutes = Math.floor(totalSeconds / 60);
                        const seconds = totalSeconds % 60;
                        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    };
                    
                    progressDisplay.textContent = `${formatTime(currentProgress)} / ${formatTime(currentDuration)}`;
                }
            }

            function showNotification(message, type = 'info') {
                // Simple notification system
                const notification = document.createElement('div');
                notification.className = `notification notification-${type}`;
                notification.textContent = message;
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    padding: 10px 20px;
                    background: ${type === 'success' ? '#4CAF50' : type === 'error' ? '#f44336' : '#2196F3'};
                    color: white;
                    border-radius: 4px;
                    z-index: 1000;
                    animation: slideIn 0.3s ease-out;
                `;

                document.body.appendChild(notification);

                setTimeout(() => {
                    notification.remove();
                }, 3000);
            }

            function openSongMenu(uri, name, artist, imageUrl) {
                // Set the song details in the modal
                window.currentSongDetails = {
                    uri: uri,
                    name: name,
                    artist: artist,
                    imageUrl: imageUrl
                };

                // Show the modal
                document.getElementById('songMenuModal').style.display = 'block';
                document.querySelector('.main-content').classList.add('blurred');

                // Dispatch event to update the song menu content
                window.dispatchEvent(new CustomEvent('updateSongMenu', { 
                    detail: { uri, name, artist, imageUrl } 
                }));
            }
        </script>
</body>

</html>