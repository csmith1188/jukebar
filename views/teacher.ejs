<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jukebar - Teacher Panel</title>
    <link rel="icon" href="/img/favicon.png">
    <script src="/socket.io/socket.io.js"></script>
</head>

<body class="teacher-page">
    <%- include('partials/header', { page: 'teacher' }) %>
        <%- include('partials/jukePixSettings') %>

        <div class="main-content">
            <div class="jukepix-toggle">
                <div style="display:flex; align-items:center; gap:12px;">
                    <div class="toggle-switch" onclick="document.getElementById('jukepixToggleCheckbox').click()">
                        <div class="switch-track">
                            <div class="switch-thumb"></div>
                        </div>
                        <input type="checkbox" id="jukepixToggleCheckbox" autocomplete="off" <%=jukepixEnabled
                            ? 'checked' : '' %>
                        style="display: none;">
                    </div>
                    <p>Enable Jukepix</p>
                    <button class="changelog-button" onclick="openJPSettings()" title="JukePix Settings">
                        <img src="/img/settings.png" alt="JukePix Settings">
                    </button>
                </div>
                <p class="user-greeting">Logged in as: <strong>
                        <%= user %>
                    </strong></p>
            </div>
            <div class="container teacher-layout">
                <div id="queueHistory">
                    <div class="section-header">
                        <h2>Queue History</h2>
                        <p class="section-subtitle">Recently played tracks</p>
                    </div>
                    <div id="historyList">
                        <p style="text-align: center; color: #b3b3b3;">Loading...</p>
                    </div>
                    <div style="text-align: center; margin-top: 20px;">
                        <button id="loadMoreHistory">Load More</button>
                    </div>
                </div>
                <div id="spotifyPlayer">
                    <div class="section-header">
                        <h2>Music Control</h2>
                        <p class="section-subtitle">Search and manage the music queue</p>
                    </div>
                    <form id="searchForm">
                        <div class="search-container">
                            <input type="text" id="searchInput" placeholder="Search for a song, artist, or album"
                                required>
                            <button type="submit" id="searchButton">
                                <img src="/img/search.png" alt="Search" class="search-icon">
                            </button>
                        </div>
                    </form>
                    <div id="searchResults"></div>
                </div>
                <div id="userManagement">
                    <div class="section-header">
                        <h2>User Management</h2>
                        <p class="section-subtitle">Manage user access and permissions</p>
                    </div>
                    <div class="user-search-container">
                        <div class="search-wrapper">
                            <input type="text" id="userSearchInput" placeholder="Search users..."
                                class="user-search-input">
                        </div>
                    </div>
                    <div class="user-list-header">
                        <span class="user-col-name">Username</span>
                        <span class="user-col-actions">Actions</span>
                    </div>
                    <div id="userList"></div>
                </div>
            </div>
        </div>
</body>
<script>
    const ownerIDs = <%- JSON.stringify(ownerIDs) %>;

    function showNotification(message, type = 'info') {
        console.log('showNotification called:', message, type);
        const notification = document.createElement('div');
        notification.className = `notification ${type === 'success' ? 'notification-success' : type === 'error' ? 'notification-error' : ''}`;
        notification.textContent = message;
        notification.style.display = 'block';
        notification.style.opacity = '1';

        document.body.appendChild(notification);
        console.log('Notification appended to body:', notification);

        setTimeout(() => {
            notification.style.opacity = '0';
            setTimeout(() => {
                notification.remove();
            }, 500);
        }, 3000);
    }

        document.getElementById('jukepixToggleCheckbox').addEventListener('change', async (e) => {
        try {
            const trackRes = await fetch('/api/currentTrack');
            const data = await trackRes.json();
            if (data.track) {
                const res = await fetch('/toggleJukepix', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ enabled: e.target.checked })
                });
                const responseData = await res.json();
                if (!res.ok || responseData.error) {
                    showNotification(responseData.error || 'Failed to update Jukepix setting', 'error');
                    e.target.checked = !e.target.checked;
                } else {
                    showNotification('Jukepix ' + (e.target.checked ? 'enabled' : 'disabled'), 'success');
                }
            } else {
                showNotification('No track is currently playing. Cannot toggle Jukepix.', 'error');
                e.target.checked = !e.target.checked;
            }
        } catch (err) {
            console.error('Error updating Jukepix setting:', err);
            showNotification('Network error updating Jukepix setting', 'error');
            e.target.checked = !e.target.checked;
        }
    });

    async function fetchUsers() {
        try {
            const res = await fetch('/api/users');
            if (!res.ok) throw new Error('Failed to fetch users');
            const users = await res.json();
            const list = document.getElementById('userList');
            list.innerHTML = '';

            if (!users.length) {
                list.innerHTML = '<div class="user-empty">No users found.</div>';
                return;
            }

            // Create a table with tbody for the user rows
            const table = document.createElement('table');
            table.className = 'user-table';
            table.style.width = '100%';
            const tbody = document.createElement('tbody');
            table.appendChild(tbody);
            list.appendChild(table);

            users.forEach(user => {
                const tr = document.createElement('tr');
                tr.className = 'user-row';
                const displayName = user.displayName || user.username || '';
                tr.dataset.username = displayName.toLowerCase();
                const isBanned = !!(user.isBanned);
                const isTeacherOrOwner = (user.permission >= 4) || ownerIDs.includes(user.id);

                const nameTd = document.createElement('td');
                let nameHtml = `<span>${displayName}</span>`;
                if (isBanned) {
                    nameHtml += '<span style="color:#ff4444;font-size:0.8em;font-weight:600;margin-left:4px;">BANNED</span>';
                }
                if (isTeacherOrOwner) {
                    nameHtml += '<span style="color:#1db954;font-size:0.8em;font-weight:600;margin-left:4px;">TEACHER</span>';
                }
                nameTd.innerHTML = nameHtml;

                const actionsTd = document.createElement('td');

                // Wrap action buttons in a flex container inside the td
                const actionsWrapper = document.createElement('div');
                actionsWrapper.style.cssText = 'display:flex;gap:6px;align-items:center;justify-content:flex-end;';

                // Transactions button
                const txnBtn = document.createElement('button');
                txnBtn.innerHTML = '<img src="/img/search.png" alt="Transactions">';
                txnBtn.title = 'View Transactions';
                txnBtn.className = 'jp-icon-btn';
                txnBtn.addEventListener('click', async () => {
                    try {
                        await showUserTransactions(user.displayName);
                    } catch (err) {
                        console.error(err);
                        alert('Failed to load transactions');
                    }
                });

                // Ban/Unban button
                const banBtn = document.createElement('button');
                banBtn.textContent = isBanned ? 'Unban' : 'Ban';
                banBtn.className = isBanned ? 'unban-button user-ban-btn' : 'ban-button user-ban-btn';
                banBtn.style.cssText = 'padding:4px 12px;font-size:0.85em;border-radius:6px;cursor:pointer;border:none;font-weight:600;';
                if (isBanned) {
                    banBtn.style.background = '#1db954';
                    banBtn.style.color = '#fff';
                } else {
                    banBtn.style.background = '#ff4444';
                    banBtn.style.color = '#fff';
                }
                banBtn.addEventListener('click', async () => {
                    const action = isBanned ? 'unban' : 'ban';
                    const confirmMsg = isBanned
                        ? `Unban ${user.displayName}? They will be able to use Jukebar again.`
                        : `Ban ${user.displayName}? They will not be able to queue songs, skip, or start ban votes.`;
                    if (!confirm(confirmMsg)) return;

                    try {
                        const r = await fetch(`/api/users/${action}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ username: user.displayName })
                        });
                        const data = await r.json();
                        if (r.ok && (data.success || data.ok)) {
                            showNotification(`${user.displayName} has been ${action === 'ban' ? 'banned' : 'unbanned'}`, 'success');
                            fetchUsers(); // Refresh the list
                        } else {
                            showNotification(data.error || `Failed to ${action} user`, 'error');
                        }
                    } catch (err) {
                        console.error(`Error ${action}ning user:`, err);
                        showNotification(`Network error: could not ${action} user`, 'error');
                    }
                });

                actionsWrapper.appendChild(txnBtn);
                if (!isTeacherOrOwner) {
                    actionsWrapper.appendChild(banBtn);
                }
                actionsTd.appendChild(actionsWrapper);
                tr.appendChild(nameTd);
                tr.appendChild(actionsTd);
                tbody.appendChild(tr);
            });
        } catch (err) {
            console.error('Error loading users:', err);
            document.getElementById('userList').innerHTML = '<div class="user-empty">Unable to load users.</div>';
        }
    }

    async function showUserTransactions(username, page = 1) {
        try {
            const res = await fetch('/api/users/transactions/modal', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ username, page, limit: 10 })
            });

            if (!res.ok) throw new Error('Failed to fetch transactions');
            const data = await res.json();

            // Create modal with the rendered HTML from partial
            const modal = document.createElement('div');
            modal.className = 'transaction-modal';
            modal.innerHTML = data.html;

            // Add pagination event listeners
            addTransactionModalEventListeners(modal, username);

            document.body.appendChild(modal);
        } catch (error) {
            console.error('Error loading transactions:', error);
            alert('Failed to load user transactions');
        }
    }

    function addTransactionModalEventListeners(modal, username) {
        const prevBtn = modal.querySelector('#prevBtn');
        const nextBtn = modal.querySelector('#nextBtn');

        // Get current page from the pagination info in the modal
        const paginationInfo = modal.querySelector('.pagination-info span').textContent;
        const currentPageMatch = paginationInfo.match(/Page (\d+) of/);
        const currentPage = currentPageMatch ? parseInt(currentPageMatch[1]) : 1;

        if (prevBtn && !prevBtn.disabled) {
            prevBtn.addEventListener('click', async () => {
                modal.remove();
                await showUserTransactions(username, currentPage - 1);
            });
        }

        if (nextBtn && !nextBtn.disabled) {
            nextBtn.addEventListener('click', async () => {
                modal.remove();
                await showUserTransactions(username, currentPage + 1);
            });
        }

        // Close modal when clicking outside
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                modal.remove();
            }
        });
    }

    let historyOffset = 0;
    const historyLimit = 20;


    // this function fetches the queue history and appends it to the history list
    async function fetchQueueHistory(reset = false) {
        if (reset) historyOffset = 0;

        try {
            const res = await fetch(`/api/queueHistory?limit=${historyLimit}&offset=${historyOffset}`);
            if (!res.ok) throw new Error('Failed to fetch queue history');
            const data = await res.json();

            const historyList = document.getElementById('historyList');

            if (reset) {
                historyList.innerHTML = '';
            }

            if (data.plays && data.plays.length > 0) {
                data.plays.forEach(play => {
                    const playDiv = document.createElement('div');
                    playDiv.className = 'queue-item';
                    playDiv.style.cssText = 'display: flex; align-items: center; border-radius: 12px; padding: 12px; margin-bottom: 8px; transition: background 0.2s ease; border: 1px solid rgba(255, 255, 255, 0.15);';

                    const date = new Date(play.timestamp);
                    const timeAgo = getTimeAgo(date);

                    // Constructs inner HTML
                    playDiv.innerHTML = `
                        <img src="${play.albumImage || '/img/placeholder.png'}" alt="${play.track_name}" class="album-cover" style="width: 60px; height: 60px; border-radius: 8px; margin-right: 16px; object-fit: cover;" />
                        <div style="flex: 1; min-width: 0;">
                            <div style="font-weight: 600; font-size: 1rem; margin: 0 0 4px 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${play.track_name}</div>
                            <div style="color: rgba(255, 255, 255, 0.7); font-size: 0.9rem; margin: 0;">${play.artist_name}</div>
                        </div>
                        <div style="text-align: right; margin-left: 16px; min-width: 120px;">
                            <div style="color: #1db954; font-size: 0.85rem; font-weight: 500;">${play.user}</div>
                            <div style="color: rgba(255, 255, 255, 0.5); font-size: 0.8rem; margin-top: 2px;">${timeAgo}</div>
                        </div>
                    `;

                    playDiv.addEventListener('mouseenter', () => {
                        playDiv.style.background = 'rgba(255, 255, 255, 0.1)';
                    });
                    playDiv.addEventListener('mouseleave', () => {
                        playDiv.style.background = 'transparent';
                    });

                    historyList.appendChild(playDiv);
                });

                historyOffset += data.plays.length;

                // Hide "Load More" if there's fewer results than requested
                if (data.plays.length < historyLimit) {
                    document.getElementById('loadMoreHistory').style.display = 'none';
                } else {
                    document.getElementById('loadMoreHistory').style.display = 'inline-block';
                }
            } else if (reset) {
                historyList.innerHTML = '<p style="text-align: center; color: #b3b3b3;">No play history found</p>';
                document.getElementById('loadMoreHistory').style.display = 'none';
            }
        } catch (err) {
            console.error('Error loading queue history:', err);
            document.getElementById('historyList').innerHTML = '<p style="text-align: center; color: #ff4444;">Failed to load history</p>';
        }
    }

    // displays the date format as M D, Y, T example: "Jun 5, 2023, 3:45 PM"
    function getTimeAgo(date) {
        return date.toLocaleString('en-US', {
            month: 'short',
            day: 'numeric',
            year: 'numeric',
            hour: 'numeric',
            minute: '2-digit',
            hour12: true
        });
    }

    document.getElementById('loadMoreHistory')?.addEventListener('click', () => {
        fetchQueueHistory(false);
    });

    document.addEventListener('DOMContentLoaded', () => {
        fetchUsers();
        fetchQueueHistory(true);
    });
    function handleSearchSubmit(event) {
        event.preventDefault();
        searchSpotify();
    }


    // search feature for banning tracks
    async function searchSpotify() {
        const query = document.getElementById('searchInput').value;
        if (!query) return;

        try {
            const response = await fetch('/search', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ query, source: 'teacher' })
            });
            const data = await response.json();
            const resultsDiv = document.getElementById('searchResults');
            resultsDiv.innerHTML = '';

            if (data.tracks && data.tracks.items.length > 0) {
                data.tracks.items.forEach(track => {
                    const isBanned = !!track.isBanned;
                    const trackDiv = document.createElement('div');
                    trackDiv.className = 'search-result-item';
                    trackDiv.innerHTML = `
                            <img src="${track.album.image}" alt="${track.album.name}" class="album-cover" />
                            <div class="search-result-content">
                                <div class="search-result-title">${track.name}</div>
                                <div class="search-result-artist">${track.artist}</div>
                            </div>
                            <button class="${isBanned ? 'unban-button' : 'ban-button'}" data-uri="${track.uri}" data-name="${track.name}" data-artist="${track.artist}" title="${isBanned ? 'Unban this track' : 'Ban this track'}">${isBanned ? 'Unban' : 'Ban'}</button>
                            `;
                    resultsDiv.appendChild(trackDiv);
                });
            } else {
                resultsDiv.innerHTML = '<p>No results found.</p>';
            }
        } catch (error) {
            console.error('Error searching Spotify:', error);
        }
    }

    const socket = io();


    // Request initial queue data on connect
    socket.on('connect', () => {
        socket.emit('requestQueueUpdate');
    });

    // Handle queue updates
    socket.on('queueUpdate', (data) => {
        updateQueueDisplay(data);
    });

    socket.on('skip', (data) => {
        updateQueueDisplay(data);
        showNotification('Track skipped', 'info');
    });

    socket.on('currentTrack', (data) => {
        updateCurrentTrackDisplay(data);
    });

    function updateQueueDisplay(data) {
        // Update the current playing track if displayed
        if (data.currentTrack) {
            updateCurrentTrackDisplay(data.currentTrack);
        }
    }

    function updateCurrentTrackDisplay(track) {
        // Add or update a current track display section
        const playerDiv = document.getElementById('spotifyPlayer');
        let currentTrackDiv = document.getElementById('currentTrack');

        if (!currentTrackDiv) {
            currentTrackDiv = document.createElement('div');
            currentTrackDiv.id = 'currentTrack';
            currentTrackDiv.className = 'current-track-display';
            playerDiv.insertBefore(currentTrackDiv, playerDiv.firstChild);
        }

        if (track) {
            currentTrackDiv.innerHTML = `
                <div class="current-track-info">
                    <h3>Currently Playing</h3>
                    <div class="track-details">
                        <img src="${track.image || '/img/default-album.png'}" alt="${track.name}" class="current-track-image" />
                        <div class="track-text">
                            <div class="current-track-name">${track.name}</div>
                            <div class="current-track-artist">${track.artist}</div>
                        </div>
                    </div>
                </div>
            `;
        } else {
            currentTrackDiv.innerHTML = `
                <div class="current-track-info">
                    <h3>Currently Playing</h3>
                    <p>No track playing</p>
                </div>
            `;
        }
    }



    const searchInput = document.getElementById('userSearchInput');
    searchInput?.addEventListener('input', () => {
        const filter = searchInput.value.toLowerCase();
        const rows = document.getElementById('userList').querySelectorAll('tr.user-row');
        rows.forEach(row => {
            row.style.display = row.dataset.username.includes(filter) ? '' : 'none';
        });
    });

    let searchDebounce = null;
    document.getElementById('searchInput')?.addEventListener('input', () => {
        clearTimeout(searchDebounce);
        const query = document.getElementById('searchInput').value.trim();
        if (!query) {
            document.getElementById('searchResults').innerHTML = '';
            return;
        }
        searchDebounce = setTimeout(() => searchSpotify(), 400);
    });

    document.getElementById('searchForm')?.addEventListener('submit', (e) => {
        e.preventDefault();
        clearTimeout(searchDebounce);
        searchSpotify();
    });
    // Ban/Unban button handler (event delegation)
    document.getElementById('searchResults')?.addEventListener('click', async (e) => {
        const banBtn = e.target.closest('.ban-button');
        const unbanBtn = e.target.closest('.unban-button');
        const btn = banBtn || unbanBtn;
        if (!btn) return;
        const name = btn.dataset.name;
        const artist = btn.dataset.artist;
        if (!name || !artist) return;

        try {
            if (banBtn) {
                const res = await fetch('/banTrack', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, artist })
                });
                const data = await res.json();
                if (res.ok && data.ok) {
                    showNotification(`Banned: ${name} - ${artist}`, 'success');
                    // Toggle to Unban
                    btn.classList.remove('ban-button');
                    btn.classList.add('unban-button');
                    btn.textContent = 'Unban';
                    btn.title = 'Unban this track';
                } else {
                    showNotification(data.error || 'Failed to ban track', 'error');
                }
            } else if (unbanBtn) {
                const res = await fetch('/unbanTrack', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, artist })
                });
                const data = await res.json();
                if (res.ok && data.ok) {
                    showNotification(`Unbanned: ${name} - ${artist}`, 'success');
                    // Toggle to Ban
                    btn.classList.remove('unban-button');
                    btn.classList.add('ban-button');
                    btn.textContent = 'Ban';
                    btn.title = 'Ban this track';
                } else {
                    showNotification(data.error || 'Failed to unban track', 'error');
                }
            }
        } catch (err) {
            console.error('Ban/Unban track error:', err);
            showNotification('Network error updating ban', 'error');
        }
    });
</script>

</html>